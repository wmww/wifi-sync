#!/usr/bin/python3

# TODO: record date of creation (ex date -r /etc/NetworkManager/system-connections/PaperBag.nmconnection)

import sys
import os
import subprocess
import re
import json
import argparse
from typing import Optional, Any

default_json_path = os.path.expanduser('~') + '/.config/wifi-sync/networks.json'

class Run:
    def __init__(self, arg_list: list[str], raise_on_fail=False):
        print('Running `' + ' '.join(arg_list) + '`')
        p = subprocess.Popen(arg_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = p.communicate(None)
        self.stdout = stdout.decode('utf-8') if stdout != None else ''
        self.stderr = stderr.decode('utf-8') if stderr != None else ''
        self.exit_code = p.returncode
        if raise_on_fail and self.exit_code != 0:
            raise RuntimeError(
                '`' + ' '.join(arg_list) + '` exited with code ' + str(self.exit_code) + ':\n' + self.stderr)

class NetworkInfo:
    def __init__(
        self,
        name: Optional[str],
        ssid: str,
        pswd_type: str,
        pswd: Optional[str],
        autoconnect: bool,
    ):
        # parse() takes values stright from JSON, so we check types here
        assert name is None or isinstance(name, str), 'name has invalid type'
        assert isinstance(ssid, str), 'ssid has invalid type'
        assert isinstance(pswd_type, str), 'pswd_type has invalid type'
        assert pswd is None or isinstance(pswd, str), 'pswd has invalid type'
        assert isinstance(autoconnect, bool), 'autoconnect has invalid type'
        if name is None:
            name = ssid
        self.name = name
        self.ssid = ssid
        if pswd_type == 'open':
            assert pswd is None, 'Open networks can not have a password'
        elif pswd_type == 'wpa':
            pass
        else:
            raise AssertionError('Unknown password type \'' + pswd_type + '\'')
        self.pswd_type = pswd_type
        self.pswd = pswd
        self.autoconnect = autoconnect

    @staticmethod
    def parse(data: dict[str, Any]) -> NetworkInfo:
        return NetworkInfo(
            data.get('name'),
            data['ssid'],
            data['pswd_type'],
            data.get('pswd'),
            data.get('autoconnect', True),
        );

    def to_dict(self) -> dict[str, Any]:
        '''For encoding to JSON'''
        data: dict[str, Any] = {}
        data['name'] = self.name
        data['ssid'] = self.ssid
        data['pswd_type'] = self.pswd_type
        if self.pswd is not None:
            data['pswd'] = self.pswd
        if not self.autoconnect:
            data['autoconnect'] = False
        return data

    def __str__(self) -> str:
        return (
            '| name: ' + self.name + '\n' +
            '| SSID: ' + self.ssid + '\n' +
            '| type: ' + self.pswd_type + '\n' +
            ('' if self.pswd is None else '| password: ' + self.pswd + '\n') +
            ('' if self.autoconnect else '| autoconnect disabled\n'))

class NetworkInterface:
    def get_networks(self, args: argparse.Namespace) -> list[NetworkInfo]:
        raise NotImplementedError()

    def add_network(self, n: NetworkInfo) -> None:
        raise NotImplementedError()

class Nmcli(NetworkInterface):
    def __init__(self):
        self.bin_path = '/usr/bin/nmcli'
        Run([self.bin_path, '-v'], raise_on_fail=True)

    def get_network_list(self) -> list[str]:
        out = Run([self.bin_path, '-f', 'NAME', 'connection'], raise_on_fail=True)
        networks = [i.strip() for i in out.stdout.strip().split('\n')[1:]] # cut off "NAME" header
        return networks

    def parse_single_network(self, name: str, data: str) -> NetworkInfo:
        ssids = re.findall('\n802-11-wireless\.ssid:\s*(.*)\n', data)
        psks = re.findall('\n802-11-wireless-security\.psk:\s*(.*)\n', data)
        key_mgmts = re.findall('\n802-11-wireless-security\.key-mgmt:\s*(.*)\n', data)
        autoconnect_nos = re.findall('\n.*\.autoconnect:\s*(no)\n', data)
        assert len(ssids) == 1, 'Could not properly detect SSID'
        assert len(psks) <= 1, 'Found more then one password'
        assert len(key_mgmts) <= 1, 'Found more then one key management'
        psk = None
        if len(psks) == 1 and psks[0] != '--':
            psk = psks[0]
        pswd_type = None
        if len(key_mgmts) == 0:
            pswd_type = 'open'
        elif key_mgmts[0] == 'none':
            raise AssertionError('WEP isn\'t properly supported yet')
            pswd_type = 'wep'
        elif key_mgmts[0] == 'wpa-psk':
            pswd_type = 'wpa'
        else:
            raise AssertionError('Unknown key management: ' + ' '.join(key_mgmts))
        autoconnect = len(autoconnect_nos) == 0
        return NetworkInfo(name, ssids[0], pswd_type, psk, autoconnect)

    def get_and_parse(self, names: list[str]) -> list[NetworkInfo]:
        out = Run([self.bin_path, '--show-secrets', 'connection', 'show'] + names, raise_on_fail=True)
        data = out.stdout.split('\n\n')
        assert len(data) == len(names), 'nmcli gave the wrong number of networks'
        networks = []
        for i in range(len(data)):
            try:
                networks.append(self.parse_single_network(names[i], data[i]))
            except Exception as e:
                print('Error with \'' + names[i] + '\': ' + str(e), file=sys.stderr)
        return networks

    def get_networks(self, args: argparse.Namespace) -> list[NetworkInfo]:
        print('Loading network list')
        names = self.get_network_list()
        try:
            print('Loading network details')
            networks = self.get_and_parse(names)
            return networks
        except Exception as e:
            print('Error: ' + str(e) + ', falling back to individual parsing', file=sys.stderr)
            print('Parsing networks individually')
            networks = []
            for name in names:
                try:
                    networks += self.get_and_parse([name])
                except Exception as e:
                    print('Error with \'' + name + '\': ' + str(e), file=sys.stderr)
            return networks

    def add_network(self, n: NetworkInfo) -> None:
        args = [self.bin_path, 'connection', 'add',
            'type', 'wifi',
            'ifname', '*',
            'con-name', n.name,
            'ssid', n.ssid,
            'save', 'yes',
            'autoconnect', 'yes' if n.autoconnect else 'no']
        if n.pswd_type == 'open':
            pass
        elif n.pswd_type == 'wpa':
            args += ['802-11-wireless-security.key-mgmt', 'wpa-psk']
            if n.pswd is not None:
                args += ['802-11-wireless-security.psk', n.pswd]
        elif n.pswd_type == 'wep':
            raise AssertionError('WEP not yet supported')
        else:
            raise AssertionError('unknown type: ' + n.pswd_type)
        result = Run(args, raise_on_fail=True)
        print('Network added:\n' + str(n))

def get_system_interface() -> NetworkInterface:
    errors = []
    for interface in [Nmcli]:
        try:
            return interface()
        except RuntimeError as e:
            errors.append(str(e))
    raise RuntimeError('\n  '.join(['No usable system interfaces detected:'] + errors))

def get_new(old_list: list[NetworkInfo], new_list: list[NetworkInfo]):
    old_dict = {}
    for i in old_list:
        old_dict[i.ssid] = True
    ret = []
    for i in new_list:
        if i.ssid not in old_dict:
            ret.append(i)
    return ret

def json_get_networks(args: argparse.Namespace) -> list[NetworkInfo]:
    path = default_json_path
    if args.file != None:
        path = args.file
    print('Loading ' + path)
    contents = '[]'
    try:
        contents = open(path, "r").read()
    except FileNotFoundError:
        print('File ' + path + ' not found, not reading', file=sys.stderr)
    print('Decoding JSON')
    loaded = json.loads(contents)
    assert isinstance(loaded, list), path + ' does not contain a list'
    networks = [NetworkInfo.parse(item) for item in loaded]
    return networks

def json_save_networks(args: argparse.Namespace, data: list[NetworkInfo]) -> None:
    path = default_json_path
    if args.file != None:
        path = args.file
    if path == default_json_path:
        os.makedirs(os.path.dirname(default_json_path), exist_ok=True)
    print('Saving to ' + path)
    output = [info.to_dict() for info in data]
    contents = json.dumps(output, indent=2)
    try:
        open(path, "w").write(contents)
    except Exception as e:
        print('Failed to write to ' + path + ' (' + str(e) + ')', file=sys.stderr)

def show_importing(
    saved: list[NetworkInfo],
    current: list[NetworkInfo],
    interface: NetworkInterface,
    args: argparse.Namespace
) -> None:
    new = get_new(current, saved)
    if new == []:
        print('No new networks in JSON file')
    else:
        print('Networks to import:\n')
        for i in new:
            if len(new) < 7:
                print(str(i))
            else:
                print('  ' + i.get('name', i['ssid']))
        for i in new:
            interface.add_network(i)

def show_exporting(
    saved: list[NetworkInfo],
    current: list[NetworkInfo],
    args: argparse.Namespace
) -> None:
    new = get_new(saved, current)
    if new == []:
        print('No new networks on system')
    else:
        print('Networks to save:\n')
        for i in new:
            if len(new) < 7:
                print(str(i))
            else:
                print('  ' + i.get('name', i['ssid']))
        saved += new
        json_save_networks(args, saved)

def import_networks(args: argparse.Namespace, interface: NetworkInterface):
    j = json_get_networks(args)
    c = interface.get_networks(args)
    show_importing(j, c, interface, args)

def export_networks(args: argparse.Namespace, interface: NetworkInterface):
    j = json_get_networks(args)
    c = interface.get_networks(args)
    show_exporting(j, c, args)

def update_networks(args: argparse.Namespace, interface: NetworkInterface):
    j = json_get_networks(args)
    c = interface.get_networks(args)
    show_exporting(j, c, args)
    j = json_get_networks(args)
    show_importing(j, c, interface, args)

def show_networks(args: argparse.Namespace, interface: NetworkInterface):
    j = json_get_networks(args)
    c = interface.get_networks(args)
    print('New networks in JSON file:\n')
    for i in get_new(c, j):
        print(str(i))
    print('New networks on system:\n')
    for i in get_new(j, c):
        print(str(i))

def main() -> None:
    parser = argparse.ArgumentParser(description='Save and load WiFi networks and passwords to JSON')
    subparsers = parser.add_subparsers()
    # subparsers.required = True
    # subparsers.dest = 'command'

    parser_load = subparsers.add_parser('import', help='Import WiFi networks from a JSON file')
    parser_load.set_defaults(func=import_networks)
    parser_load.add_argument('-f', '--file', type=str, help='File to import networks from, default is ' + default_json_path)

    parser_load = subparsers.add_parser('export', help='Export WiFi networks to a JSON file')
    parser_load.set_defaults(func=export_networks)
    parser_load.add_argument('-f', '--file', type=str, help='File to export networks to, default is ' + default_json_path)

    parser_load = subparsers.add_parser('update', help='Import and export')
    parser_load.set_defaults(func=update_networks)
    parser_load.add_argument('-f', '--file', type=str, help='JSON file to use, default is ' + default_json_path)


    parser_load = subparsers.add_parser('show', help='Show all WiFi networks loaded from the JSON file and detected from system')
    parser_load.set_defaults(func=show_networks)
    parser_load.add_argument('-f', '--file', type=str, help='File to load networks from, default is ' + default_json_path)

    args = parser.parse_args()

    if not hasattr(args, 'func'):
        parser.print_help()
        exit(1)

    interface = get_system_interface()
    args.func(args, interface)

if __name__ == '__main__':
    main()
