#!/usr/bin/python3

# TODO: record date of creation (ex date -r /etc/NetworkManager/system-connections/PaperBag.nmconnection)

import sys
import os
import math
import subprocess
import re
import json
import argparse
from datetime import datetime
from typing import Optional, Any, Tuple

default_json_path = os.path.expanduser('~') + '/.config/wifi-sync/networks.json'

class Run:
    def __init__(self, arg_list: list[str], raise_on_fail=False):
        print('Running `' + ' '.join(arg_list) + '`')
        p = subprocess.Popen(arg_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = p.communicate(None)
        self.stdout = stdout.decode('utf-8') if stdout != None else ''
        self.stderr = stderr.decode('utf-8') if stderr != None else ''
        self.exit_code = p.returncode
        if raise_on_fail and self.exit_code != 0:
            raise RuntimeError(
                '`' + ' '.join(arg_list) + '` exited with code ' + str(self.exit_code) + ':\n' + self.stderr)

class NetworkInfo:
    def __init__(
        self,
        name: Optional[str],
        ssid: str,
        nm_uuid: Optional[str],
        pswd_type: str,
        pswd: Optional[str],
        autoconnect: bool,
        created_at: Optional[float],
    ):
        # parse() takes values stright from JSON, so we check types here
        assert name is None or isinstance(name, str), 'name has invalid type'
        assert isinstance(ssid, str), 'ssid has invalid type'
        assert isinstance(pswd_type, str), 'pswd_type has invalid type'
        assert pswd is None or isinstance(pswd, str), 'pswd has invalid type'
        assert isinstance(autoconnect, bool), 'autoconnect has invalid type'
        assert created_at is None or isinstance(created_at, float), 'created_at has invalid type'
        if name is None:
            name = ssid
        self.name: str = name
        self.ssid: str = ssid
        if pswd_type == 'open':
            assert pswd is None, 'Open networks can not have a password'
        elif pswd_type == 'wpa':
            pass
        else:
            raise AssertionError('Unknown password type \'' + pswd_type + '\'')
        self.nm_uuid = nm_uuid
        self.pswd_type: str = pswd_type
        self.pswd: Optional[str] = pswd
        self.autoconnect: bool = autoconnect
        self.created_at: Optional[float] = created_at

    @staticmethod
    def parse(data: dict[str, Any]) -> 'NetworkInfo':
        return NetworkInfo(
            data.get('name'),
            data['ssid'],
            None,
            data['pswd_type'],
            data.get('pswd'),
            data.get('autoconnect', True),
            data.get('created_at', None),
        );

    def to_dict(self) -> dict[str, Any]:
        '''For encoding to JSON'''
        data: dict[str, Any] = {}
        data['name'] = self.name
        data['ssid'] = self.ssid
        data['pswd_type'] = self.pswd_type
        if self.pswd is not None:
            data['pswd'] = self.pswd
        if not self.autoconnect:
            data['autoconnect'] = False
        if self.created_at is not None:
            data['created_at'] = self.created_at
            data['readable_time'] = datetime.utcfromtimestamp(self.created_at).strftime(
                "%b %d, %Y %H:%M UTC"
            )
        return data

    def __str__(self) -> str:
        return (
            '| name: ' + self.name + '\n' +
            '| SSID: ' + self.ssid + '\n' +
            '| type: ' + self.pswd_type + '\n' +
            ('' if self.pswd is None else '| password: ' + self.pswd + '\n') +
            ('' if self.autoconnect else '| autoconnect disabled\n'))

def format_network_list(title: str, networks: list[NetworkInfo]) -> str:
    result = title + ':\n'
    for network in networks:
        if len(networks) < 7:
            result += str(network) + '\n'
        else:
            result += '  ' + network.name + ' (' + network.ssid + ')' + '\n'
    return result

class NetworkInterface:
    def __init__(self):
        self.current: Optional[List[NetworkInfo]] = None
        self.pending_remove: List[NetworkInfo] = []
        self.pending_add: List[NetworkInfo] = []

    def __str__(self) -> str:
        raise NotImplementedError()

    def match(self, a: NetworkInfo, b: NetworkInfo) -> bool:
        '''Returns if two networks are equal in terms of what this interface cares about'''
        raise NotImplementedError()

    def load(self) -> None:
        '''Loads the current state'''
        raise NotImplementedError()

    def commit(self) -> None:
        '''Saves and clears pending networks'''
        raise NotImplementedError()

    def get_current(self) -> list[NetworkInfo]:
        assert self.current is not None, str(self) + ' not loaded'
        return self.current

    def queue_network(self, network: NetworkInfo) -> None:
        '''Puts the network in pending if it's not already known'''
        to_remove: list[NetworkInfo] = []
        for known in self.get_current() + self.pending_add:
            if known.ssid == network.ssid:
                if self.match(known, network):
                    return
                else:
                    to_remove.append(known)
        self.pending_remove += to_remove
        self.pending_add.append(network)

    def queue_all_networks(self, networks: list[NetworkInfo]) -> None:
        '''Puts any new networks in pending_add'''
        for network in networks:
            self.queue_network(network)


class Nmcli(NetworkInterface):
    def __init__(self):
        super().__init__()
        self.bin_path = '/usr/bin/nmcli'
        self.data_path = '/etc/NetworkManager/system-connections'
        Run([self.bin_path, '-v'], raise_on_fail=True)
        self.conn_id_re = re.compile(r'^connection\.id:\s*(.*)$', flags=re.MULTILINE)
        self.conn_uuid_re = re.compile(r'^connection\.uuid:\s*(.*)$', flags=re.MULTILINE)
        self.conn_type_re = re.compile(r'^connection\.type:\s*(.*)$', flags=re.MULTILINE)
        self.ssid_re = re.compile(r'^802-11-wireless\.ssid:\s*(.*)$', flags=re.MULTILINE)
        self.psk_re = re.compile(r'^802-11-wireless-security\.psk:\s*(.*)$', flags=re.MULTILINE)
        self.key_mgmt_re = re.compile(r'^802-11-wireless-security\.key-mgmt:\s*(.*)$', flags=re.MULTILINE)
        self.autoconnect_no_re = re.compile(r'^.*\.autoconnect:\s*(no)$', flags=re.MULTILINE)

    def __str__(self) -> str:
        return 'NetworkManager'

    def match(self, a: NetworkInfo, b: NetworkInfo) -> bool:
        return (
            a.ssid == b.ssid and
            a.pswd_type == b.pswd_type and
            a.pswd == b.pswd and
            a.autoconnect == b.autoconnect
        )

    def name_list(self) -> list[str]:
        out = Run([self.bin_path, '-f', 'NAME', 'connection'], raise_on_fail=True)
        networks = [i.strip() for i in out.stdout.strip().split('\n')[1:]] # cut off "NAME" header
        return list(set(networks))

    def get_created_at(self, name: str, uuid: str) -> float:
        paths = [
            os.path.join(self.data_path, name + '-' + uuid + '.nmconnection'),
            os.path.join(self.data_path, name + '-' + uuid),
            os.path.join(self.data_path, name + '.nmconnection'),
            os.path.join(self.data_path, name),
        ]
        time = math.inf
        for path in paths:
            try:
                time = min(time, os.path.getmtime(path))
            except FileNotFoundError:
                pass
        # If we're before 2000 or after 2050, something is wrong
        assert time > 946684800.0 and time < 2524608000.0, 'Invalid time ' + str(time)
        return time

    def parse_single_network(self, data: str) -> Optional[NetworkInfo]:
        conn_types = self.conn_type_re.findall(data)
        assert len(conn_types) == 1, 'Could not properly detect connection type'
        if conn_types[0] == '802-11-wireless':
            pass
        elif conn_types[0] == '802-3-ethernet' or conn_types[0] == 'bridge':
            return None
        else:
            raise AssertionError('Invalid connection type ' + conn_types[0])
        conn_ids = self.conn_id_re.findall(data)
        conn_uuids = self.conn_uuid_re.findall(data)
        ssids = self.ssid_re.findall(data)
        psks = self.psk_re.findall(data)
        key_mgmts = self.key_mgmt_re.findall(data)
        autoconnect_nos = self.autoconnect_no_re.findall(data)
        assert len(conn_ids) == 1, 'Could not properly detect connection ID'
        assert len(conn_uuids) == 1, 'Could not properly detect connection UUID'
        assert len(ssids) == 1, 'Could not properly detect SSID'
        assert len(psks) <= 1, 'Found more then one password'
        assert len(key_mgmts) <= 1, 'Found more then one key management:\n'
        psk = None
        if len(psks) == 1 and psks[0] != '--':
            psk = psks[0]
        pswd_type = None
        if len(key_mgmts) == 0:
            pswd_type = 'open'
        elif key_mgmts[0] == 'none':
            # This means WEP, which isn't supported
            # pswd_type = 'wep'
            return None
        elif key_mgmts[0] == 'wpa-psk':
            pswd_type = 'wpa'
        else:
            raise AssertionError('Unknown key management: ' + ' '.join(key_mgmts))
        autoconnect = len(autoconnect_nos) == 0
        created_at = self.get_created_at(conn_ids[0], conn_uuids[0])
        return NetworkInfo(conn_ids[0], ssids[0], conn_uuids[0], pswd_type, psk, autoconnect, created_at)

    def parse_network_list(self, names: list[str]) -> list[NetworkInfo]:
        out = Run([self.bin_path, '--show-secrets', 'connection', 'show'] + names, raise_on_fail=True)
        data = out.stdout.split('\n\n')
        networks = []
        for i in range(len(data)):
            network = self.parse_single_network(data[i])
            if network is not None:
                networks.append(network)
        return networks

    def load(self) -> None:
        print('Loading ' + str(self))
        names = self.name_list()
        print('Loading network details')
        self.current = self.parse_network_list(names)

    def install_network(self, n: NetworkInfo) -> None:
        args = [self.bin_path, 'connection', 'add',
            'type', 'wifi',
            'ifname', '*',
            'con-name', n.name,
            'ssid', n.ssid,
            'save', 'yes',
            'autoconnect', 'yes' if n.autoconnect else 'no']
        if n.pswd_type == 'open':
            pass
        elif n.pswd_type == 'wpa':
            args += ['802-11-wireless-security.key-mgmt', 'wpa-psk']
            if n.pswd is not None:
                args += ['802-11-wireless-security.psk', n.pswd]
        elif n.pswd_type == 'wep':
            raise AssertionError('WEP not yet supported')
        else:
            raise AssertionError('unknown type: ' + n.pswd_type)
        result = Run(args, raise_on_fail=True)
        print('Network added:\n' + str(n))

    def delete_network(self, n: NetworkInfo) -> None:
        print('remove_network() not implemented for ' + str(self))

    def commit(self) -> None:
        if len(self.pending_add) == 0 and len(self.pending_remove):
            print('No new networks to import into ' + str(self))
            return
        print(format_network_list('Networks to delete from ' + str(self), self.pending_remove))
        print(format_network_list('Networks to import into ' + str(self), self.pending_add))
        for network in self.pending_remove:
            self.delete_network(network)
        for network in self.pending_add:
            self.install_network(network)
        self.pending_add = []
        self.pending_remove = []
        self.current = None

class JsonFile(NetworkInterface):
    def __init__(self, path: str):
        super().__init__()
        self.path = path

    def __str__(self) -> str:
        return self.path

    def match(self, a: NetworkInfo, b: NetworkInfo) -> bool:
        created_at_eq = (
            (a.created_at is None and
             b.created_at is None) or
            (a.created_at is not None and
             b.created_at is not None and
             abs(a.created_at - b.created_at) > 1)
        )
        return (
            a.name == b.name and
            a.ssid == b.ssid and
            a.pswd_type == b.pswd_type and
            a.pswd == b.pswd and
            a.autoconnect == b.autoconnect and
            created_at_eq
        )

    def load(self) -> None:
        print('Loading JSON from', self.path)
        with open(self.path, "r") as f:
            contents = f.read()
        loaded = json.loads(contents)
        assert isinstance(loaded, list), self.path + ' does not contain a list'
        self.current = [NetworkInfo.parse(item) for item in loaded]

    def commit(self) -> None:
        if len(self.pending_add) == 0 and len(self.pending_remove) == 0:
            print('No new networks to export to ' + str(self))
            return
        print(format_network_list('Networks to delete from ' + str(self), self.pending_remove))
        print(format_network_list('Networks to export to ' + str(self), self.pending_add))
        print('Saving JSON to', self.path)
        output = [
            network.to_dict()
            for network in self.current + self.pending_add
            if network not in self.pending_remove
        ]
        contents = json.dumps(output, indent=2)
        with open(self.path, "w") as f:
            f.write(contents)
        self.pending_add = []
        self.pending_remove = []
        self.current = None

def make_system_interface(args: argparse.Namespace) -> NetworkInterface:
    errors = []
    for interface in [Nmcli]:
        try:
            return interface()
        except RuntimeError as e:
            errors.append(str(e))
    raise RuntimeError('\n  '.join(['No usable system interfaces detected:'] + errors))

def make_config_interface(args: argparse.Namespace) -> NetworkInterface:
    path = default_json_path
    if args.file is not None:
        path = args.file
    if path == default_json_path:
        os.makedirs(os.path.dirname(default_json_path), exist_ok=True)
    return JsonFile(path)

def load_all(args: argparse.Namespace) -> Tuple[NetworkInterface, NetworkInterface]:
    config = make_config_interface(args)
    config.load()
    system = make_system_interface(args)
    system.load()
    return config, system

def import_networks(args: argparse.Namespace):
    config, system = load_all(args)
    system.queue_all_networks(config.get_current())
    system.commit()

def export_networks(args: argparse.Namespace):
    config, system = load_all(args)
    config.queue_all_networks(system.get_current())
    config.commit()

def update_networks(args: argparse.Namespace):
    config, system = load_all(args)
    config.queue_all_networks(system.get_current())
    config.commit()
    config.load()
    system.queue_all_networks(config.get_current())
    system.commit()

def show_networks(args: argparse.Namespace):
    config, system = load_all(args)
    config.queue_all_networks(system.get_current())
    system.queue_all_networks(config.get_current())
    print(format_network_list('New networks from ' + str(config), system.pending_add))
    print(format_network_list('New networks from ' + str(system), config.pending_add))

def main() -> None:
    parser = argparse.ArgumentParser(description='Save and load WiFi networks and passwords to JSON')
    subparsers = parser.add_subparsers()
    # subparsers.required = True
    # subparsers.dest = 'command'

    subparser = subparsers.add_parser('import', help='Import WiFi networks from a JSON file')
    subparser.set_defaults(func=import_networks)
    subparser.add_argument('-f', '--file', type=str, help='File to import networks from, default is ' + default_json_path)

    subparser = subparsers.add_parser('export', help='Export WiFi networks to a JSON file')
    subparser.set_defaults(func=export_networks)
    subparser.add_argument('-f', '--file', type=str, help='File to export networks to, default is ' + default_json_path)

    subparser = subparsers.add_parser('update', help='Import and export')
    subparser.set_defaults(func=update_networks)
    subparser.add_argument('-f', '--file', type=str, help='JSON file to use, default is ' + default_json_path)


    subparser = subparsers.add_parser('show', help='Show all WiFi networks loaded from the JSON file and detected from system')
    subparser.set_defaults(func=show_networks)
    subparser.add_argument('-f', '--file', type=str, help='File to load networks from, default is ' + default_json_path)

    args = parser.parse_args()

    if not hasattr(args, 'func'):
        parser.print_help()
        exit(1)

    args.func(args)

if __name__ == '__main__':
    main()
